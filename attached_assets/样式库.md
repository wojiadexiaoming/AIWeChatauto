好的，这就是你想要的通用模板 + 自动化生成的思路！

由于微信公众号 API 对 content 字段的限制（去除 JS，图片 URL 必须是微信上传的，且通常会过滤 <style> 标签），我们无法在最终提交的 HTML 中使用 <style> 标签或外部 CSS 文件来定义通用样式。

核心思想：内容创作者以一种“简洁、易维护”的方式编写内容（例如带有 CSS 类的 HTML），然后通过一个“自动化脚本”将这些样式“编译”或“内联”到 HTML 元素的 style 属性中，同时处理图片 URL，最终生成符合微信 API 要求的 HTML 字符串。

这个过程就像前端开发中的 CSS 预处理器 + 构建工具，只是目标是生成微信兼容的 HTML。

通用模板的实现思路（自动化脚本方案）

这个方案主要分为三个部分：

模板定义（由你提前编写和维护）：

CSS 样式文件： 定义所有通用样式和组件样式，使用 CSS 类选择器。

HTML 内容模板： 编写文章内容时，使用 HTML 标签和对应的 CSS 类名，图片路径可以是本地路径或占位符。

自动化脚本（核心逻辑）：

读取 HTML 内容模板和 CSS 样式文件。

图片上传与 URL 替换：识别 HTML 中的本地图片路径，通过微信 API 上传图片，并将 src 替换为微信返回的 URL。

CSS 内联：将 CSS 样式文件中的所有 CSS 规则应用到 HTML 元素上，转换为行内 style 属性。

生成最终的微信 API content 字符串。

微信 API 调用：将生成的 content 字符串通过 draft_add 接口提交。

步骤详解与代码思路

第一步：定义通用样式（template.css）

这是你的“样式库”。在这里定义你所有文章可能用到的样式，例如正文、标题、提示框、代码块、图片居中等。使用类选择器。

Generated css
/* template.css - 你的通用样式库 */

/* 全局基础样式（注意：如果body标签也写在content里，这些会内联到body上；否则需要给最外层section一个类） */
.rich-media-body {
    background-image: url('{{ WECHAT_BACKGROUND_IMAGE_URL }}'); /* 占位符，脚本会替换 */
    background-repeat: repeat;
    background-size: 83.5052%;
    line-height: 1.8;
    letter-spacing: 2px;
    font-style: normal;
    text-align: justify;
    color: rgb(62, 62, 62); /* 默认文本颜色 */
}

/* 正文段落（文字加粗且大小统一） */
.article-paragraph {
    font-size: 17px;
    font-weight: bold;
    color: rgb(63, 63, 63);
    margin: 0px;
    padding: 0px;
}

/* 标题样式 */
.article-heading {
    color: rgb(50, 120, 71); /* 绿色主色 */
    letter-spacing: 0.578px;
    margin-top: 20px; /* 标题上方留白 */
    margin-bottom: 8px; /* 标题下方留白 */
    padding-bottom: 12px;
    /* font-family 也可以在这里定义 */
}
/* 标题高亮背景 */
.article-heading .highlight {
    background-color: rgba(255, 246, 122, 0.8);
}

/* 行内代码 */
.inline-code {
    color: rgb(63, 63, 63);
    padding: 1px 2px;
    background-color: rgb(245, 246, 247);
    border: 1px solid rgb(222, 224, 227);
    border-radius: 4px;
    margin: 0px 3px;
    font-family: monospace; /* 确保等宽字体 */
}

/* 代码块容器 */
.code-block-container {
    background-color: rgb(40, 44, 52);
    border-radius: 5px;
    margin: 12px 0;
    padding: 15px; /* 整体内边距 */
    overflow-x: auto; /* 横向滚动 */
}
/* 代码块内容 */
.code-block-container pre code {
    color: rgb(171, 178, 191); /* 代码文本颜色 */
    font-family: Consolas, Monaco, Menlo, monospace;
    line-height: 1.5;
    display: block; /* 确保代码块内部内容独占一行 */
}
/* 代码块语法高亮 */
.code-block-container .keyword { color: rgb(209, 154, 102); }
.code-block-container .string { color: rgb(152, 195, 121); }

/* 提示/引用框 */
.tip-box {
    border-left: 3px solid rgb(50, 120, 71);
    background-color: rgb(245, 247, 239);
    padding: 0px 4px 0px 12px; /* 左侧留出更多空间给边框 */
    margin-bottom: 12px;
    color: rgb(63, 63, 63); /* 提示框内文本颜色 */
}

/* 图片容器（用于居中） */
.image-wrapper {
    text-align: center;
    margin: 10px 0; /* 图片上下间距 */
}
/* 图片本身样式 */
.responsive-image {
    display: inline-block;
    max-width: 100%;
    height: auto;
    border-radius: 12px;
    /* width 属性在<img>标签的style里定义更灵活，或在此处设置一个max-width */
}

/* 特殊文本颜色 */
.text-blue-link {
    text-decoration: underline;
    color: rgb(51, 109, 244);
}
.text-red-emphasis {
    color: rgb(216, 57, 49); /* 深红色强调 */
}


第二步：编写文章内容模板（article_content.html）

这是你的“内容草稿”。使用简洁的 HTML 结构，应用你 CSS 文件中定义的类名。图片 src 属性暂时使用本地路径或相对路径。

Generated html
<!-- article_content.html - 你的文章草稿 -->

<section class="rich-media-body"> <!-- 整体内容容器，应用全局背景和基础文本样式 -->
    <!-- 公众号名片这类通常是微信编辑器插入的模块，如果API不支持，这里就不能直接写 -->

    <p class="article-paragraph"><span><br></span></p>
    <p class="article-paragraph"><span>大家好！我是舰长</span></p>
    <p class="article-paragraph"><span>最近舰长一直在研究<span class="inline-code">n8n</span>，没错就是现在最火的那个开源智能体平台——n8n。</span></p>
    <p class="article-paragraph"><span>这个平台一直被“自动化平台”标签所覆盖，那舰长也来看一下到底有没有说的那么神！当舰长打开n8n平台的时候呢首先也是被工作流编排页面所吸引！</span></p>

    <section class="image-wrapper">
        <img class="responsive-image" src="./assets/workflow_preview.png" style="width: 677px !important;" alt="工作流预览"> <!-- 本地图片路径 -->
    </section>

    <p class="article-paragraph"><span><br></span></p>
    <h3 class="article-heading"><span class="highlight">5分钟本地部署n8n</span></h3>
    <p class="article-paragraph"><span>本次部署采用Docker容器部署方式，官方的部署方案会导致数据丢失的问题，所以采用Docker部署的方式比较稳妥！</span></p>

    <section class="tip-box">
        <p class="article-paragraph"><span>小tips：下载好是可以直接不登入进行使用的，登入板块会有点问题导致登入不上，其实登入和不登入都可以使用；所以在登入页面直接选择跳过即可！</span></p>
    </section>

    <p class="article-paragraph"><span>输入下面的这个docker部署指令：（指令如果不能用可以让deepseek修改一下，这边微信格式有问题）</span></p>
    <p class="article-paragraph"><span>Windows：</span></p>
    <section class="code-block-container">
        <pre><code><span class="article-paragraph"><span leaf="">docker run -d ^  <span class="keyword">--name</span> n8n ^  -p </span><span class="keyword">5678</span><span leaf="">:</span><span class="keyword">5678</span><span leaf=""> ^  -e GENERIC_TIMEZONE=</span><span class="string">"Asia/Shanghai"</span><span leaf=""> ^  -e TZ=</span><span class="string">"Asia/Shanghai"</span><span leaf=""> ^  -v C:\本地路径\n8n:/home/node/.n8n ^  -v C:\本地路径\n8ndata:/home/node/n8ndata ^  docker.n8n.io/n8nio/n8n</span></span></code></pre>
    </section>

    <p class="article-paragraph"><span><br></span></p>
    <p class="article-paragraph"><span>本次的分享内容就到这！有对n8n感兴趣的小伙伴可以部署一下n8n，<span class="text-red-emphasis">如果在部署中有什么问题可以添加下方二维码进舰长的交流群中进行交流。</span></span></p>
    <p class="article-paragraph" style="text-align: center;"><span class="article-paragraph">关注公众号并添加舰长微信，领取智能体学习资料，并参与智能体技术直播讲解</span></p>
    <section class="image-wrapper">
        <img class="responsive-image" src="./assets/wechat_qrcode_1.png" style="width: 677px !important;" alt="微信二维码1">
    </section>
    <!-- 更多内容... -->

</section>
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution. 
Html
IGNORE_WHEN_COPYING_END

第三步：自动化脚本（以 Python 为例）

这个脚本将读取你的 article_content.html 和 template.css，进行处理，然后生成最终的 content 字符串。

Generated python
import requests
from bs4 import BeautifulSoup
from premailer import transform
import os

# --- 微信API配置 ---
APP_ID = '你的公众号AppID'
APP_SECRET = '你的公众号AppSecret'
ACCESS_TOKEN_URL = f"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={APP_ID}&secret={APP_SECRET}"
UPLOAD_IMG_URL = "https://api.weixin.qq.com/cgi-bin/media/uploadimg" # 上传图文消息图片
ADD_DRAFT_URL = "https://api.weixin.qq.com/cgi-bin/draft/add" # 新增草稿

# --- 文件路径 ---
CSS_FILE = 'template.css'
HTML_TEMPLATE_FILE = 'article_content.html'
ASSETS_DIR = './assets' # 存放本地图片的目录

# --- 通用背景图路径（如果需要的话，脚本会上传并替换占位符） ---
LOCAL_BACKGROUND_IMAGE_PATH = './assets/background_stripes.png' # 假设你的条纹背景图在这里

def get_access_token():
    """获取微信Access Token"""
    response = requests.get(ACCESS_TOKEN_URL)
    response.raise_for_status() # 如果请求失败，抛出异常
    return response.json()['access_token']

def upload_image_to_wechat(access_token, image_path):
    """上传图片到微信并获取URL"""
    if not os.path.exists(image_path):
        print(f"WARN: 图片文件不存在: {image_path}")
        return None # 或抛出异常

    with open(image_path, 'rb') as f:
        files = {'media': f}
        upload_url = f"{UPLOAD_IMG_URL}?access_token={access_token}"
        response = requests.post(upload_url, files=files)
        response.raise_for_status()
        result = response.json()
        if 'url' in result:
            print(f"图片上传成功: {image_path} -> {result['url']}")
            return result['url']
        else:
            print(f"图片上传失败: {image_path}, 错误: {result}")
            return None

def process_article_content(access_token, html_template, css_styles):
    """
    处理文章内容：上传图片并替换URL，然后进行CSS内联
    """
    soup = BeautifulSoup(html_template, 'html.parser')

    # --- 1. 处理背景图片URL占位符 ---
    final_css_styles = css_styles
    if '{{ WECHAT_BACKGROUND_IMAGE_URL }}' in css_styles and LOCAL_BACKGROUND_IMAGE_PATH:
        wechat_bg_url = upload_image_to_wechat(access_token, LOCAL_BACKGROUND_IMAGE_PATH)
        if wechat_bg_url:
            final_css_styles = final_css_styles.replace('{{ WECHAT_BACKGROUND_IMAGE_URL }}', wechat_bg_url)
        else:
            print("ERROR: 背景图片上传失败，将使用空背景URL。")
            final_css_styles = final_css_styles.replace('{{ WECHAT_BACKGROUND_IMAGE_URL }}', '') # 替换为空，避免API报错

    # --- 2. 处理所有<img>标签的src ---
    for img_tag in soup.find_all('img', class_='responsive-image'):
        local_src = img_tag.get('src')
        if local_src and not local_src.startswith(('http://', 'https://')): # 检查是否是本地路径
            full_image_path = os.path.join(os.path.dirname(HTML_TEMPLATE_FILE), local_src) # 假设图片在HTML文件同级或子目录
            wechat_img_url = upload_image_to_wechat(access_token, full_image_path)
            if wechat_img_url:
                img_tag['src'] = wechat_img_url
            else:
                print(f"WARN: 图片 {local_src} 上传失败，其URL将保留本地路径或为空。")

    # --- 3. CSS 内联 ---
    # premailer会将<style>标签中的CSS规则内联到HTML元素的style属性中
    # 并且会移除<style>标签，这正是我们想要的
    inlined_html = transform(str(soup),
                             external_styles=[final_css_styles],
                             keep_style_tags=False,
                             strip_important=False, # 如果你的CSS里有!important，可能需要保留
                             # base_url 可以在你需要处理相对路径或绝对路径转换时使用
                             )
    return inlined_html

def add_draft_to_wechat(access_token, title, content, thumb_media_id, author="", digest="", content_source_url=""):
    """新增图文草稿到微信公众号"""
    payload = {
        "articles": [
            {
                "article_type": "news",
                "title": title,
                "author": author,
                "digest": digest,
                "content": content,
                "content_source_url": content_source_url,
                "thumb_media_id": thumb_media_id,
                "need_open_comment": 0,
                "only_fans_can_comment": 0
            }
        ]
    }
    add_draft_url = f"{ADD_DRAFT_URL}?access_token={access_token}"
    response = requests.post(add_draft_url, json=payload)
    response.raise_for_status()
    return response.json()

# --- 主执行流程 ---
if __name__ == "__main__":
    try:
        # 1. 获取Access Token
        print("获取微信Access Token...")
        access_token = get_access_token()
        print(f"Access Token: {access_token[:10]}...") # 打印部分，避免泄露

        # 2. 读取CSS和HTML内容模板
        print("读取CSS样式和HTML内容模板...")
        css_styles = open(CSS_FILE, 'r', encoding='utf-8').read()
        html_template = open(HTML_TEMPLATE_FILE, 'r', encoding='utf-8').read()

        # 3. 处理HTML内容（图片上传+CSS内联）
        print("处理文章内容（图片上传与URL替换，CSS内联）...")
        final_article_content = process_article_content(access_token, html_template, css_styles)
        print(f"处理后的HTML字符数: {len(final_article_content)}")
        # 可以保存一份处理后的HTML供本地预览
        with open('output_wechat_content.html', 'w', encoding='utf-8') as f:
            f.write(final_article_content)
        print("处理后的HTML已保存到 output_wechat_content.html")

        # --- 假设封面图也需要上传，这里简化为一个已有的media_id ---
        # 如果封面图也是本地的，需要在这里也调用upload_image_to_wechat接口，然后用返回的media_id
        # 例如：
        # thumb_media_id = upload_image_to_wechat(access_token, './assets/cover_image.png')
        # ... 或者直接用一个已经上传好的永久素材ID
        # 实际操作中，thumb_media_id 应该来自 media/upload API 而不是 uploadimg
        # 这里简化为占位符，因为uploadimg返回的是url，upload返回的是media_id
        # 封面图通常用 media/upload 接口上传，类型为 'thumb'，返回的是 media_id
        # 此处为了演示简化，假设你已有或另外处理了封面media_id
        # IMPORTANT: 微信API的 thumb_media_id 字段需要的是 `media/upload` 接口返回的 media_id，
        # 而非 `media/uploadimg` 返回的 URL。
        # 你需要根据实际情况修改这一部分。
        sample_thumb_media_id = "YOUR_PERMANENT_THUMB_MEDIA_ID_HERE" # 替换为你实际的封面图media_id

        # 4. 调用微信API新增草稿
        print("调用微信API新增草稿...")
        article_title = "【船长AI】使用Docker5分钟本地部署N8N，告别官方高额费用！" # 你的文章标题
        article_author = "杰克船长"
        article_digest = "告别高额官方费用！手把手教你5分钟本地部署开源智能体平台n8n，轻松搭建自动化工作流，比Coze更自由！"
        # 确保 final_article_content 的长度符合微信API的限制
        if len(final_article_content) > 20000:
            print("ERROR: 文章内容超过20000字符限制，请精简内容。")
        else:
            result = add_draft_to_wechat(
                access_token=access_token,
                title=article_title,
                content=final_article_content,
                thumb_media_id=sample_thumb_media_id,
                author=article_author,
                digest=article_digest
            )
            print("草稿新增成功！")
            print(result)

    except requests.exceptions.RequestException as e:
        print(f"API请求错误: {e}")
    except Exception as e:
        print(f"发生未知错误: {e}")
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution. 
Python
IGNORE_WHEN_COPYING_END
如何使用这个思路：

准备环境：

确保你安装了 Python (建议 3.7+)

安装必要的库：pip install requests beautifulsoup4 premailer

在你的 Python 脚本中填写 APP_ID 和 APP_SECRET。

准备素材：

将你的通用样式写在 template.css 文件中。

将你的文章内容写在 article_content.html 文件中，使用你在 template.css 中定义的类名。

将所有本地图片（包括条纹背景图和文章中的所有图片）放到 assets 文件夹下，并在 article_content.html 中引用正确的相对路径（例如 src="./assets/image.png"）。

运行脚本：

python your_script_name.py

脚本会依次执行：获取 Access Token -> 上传图片并替换 HTML 中的 URL -> 将 CSS 内联到 HTML -> 调用微信 API 创建草稿。

检查：

运行脚本后，可以在微信公众平台后台的“草稿箱”中查看新生成的文章草稿。检查其排版、样式和图片是否都正确显示。

这个方案的优点：

极大地减少了你的编写量： 你只需要关心 HTML 结构和类名，而无需手动编写或复制粘贴复杂的行内样式。

集中管理样式： 所有样式都在 template.css 中，修改一个类就能影响所有使用该类的元素。

自动化图片上传： 解决了微信图片 URL 的限制，无需手动上传和替换。

错误减少： 脚本自动化处理，降低了手动操作带来的错误。

内容与样式分离： 更符合现代 Web 开发的理念，内容更纯粹，样式更专业。

通过这种方式，你可以在保证微信兼容性的前提下，实现高效、专业的公众号文章发布流程。